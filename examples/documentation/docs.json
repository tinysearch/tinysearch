[
    {
        "title": "Getting Started Guide",
        "content": "Welcome to TinySearch! This guide will help you get up and running with TinySearch for your static website. TinySearch is a lightweight, fast, full-text search engine written in Rust and compiled to WebAssembly. It's designed specifically for static websites where you need client-side search functionality without requiring a backend server. The entire search index is embedded in a small WASM file that runs directly in the browser. Installation is straightforward using cargo, and the generated output can be integrated into any static site generator like Jekyll, Hugo, or Gatsby.",
        "section": "Introduction",
        "keywords": "installation setup quickstart beginner guide static-website",
        "doc_url": "https://docs.example.com/getting-started",
        "version": "v0.9.0",
        "last_updated": "2024-03-01",
        "contributor": "TinySearch Team",
        "difficulty": "Beginner",
        "type": "Guide"
    },
    {
        "title": "Configuration Reference",
        "content": "TinySearch can be configured using a tinysearch.toml file to customize which JSON fields are indexed versus stored as metadata. The schema section allows you to specify indexed_fields for full-text search, metadata_fields for display-only data, and url_field for the link destination. This flexible configuration system allows TinySearch to work with any JSON structure, from simple blog posts to complex e-commerce catalogs. Field mapping is automatic, and the system intelligently handles different JSON value types including strings, numbers, booleans, and arrays. Advanced configuration options include custom stopwords, stemming rules, and index optimization settings.",
        "section": "Configuration",
        "keywords": "tinysearch.toml schema configuration json fields indexed metadata",
        "doc_url": "https://docs.example.com/configuration",
        "version": "v0.9.0", 
        "last_updated": "2024-02-28",
        "contributor": "Sarah Chen",
        "difficulty": "Intermediate",
        "type": "Reference"
    },
    {
        "title": "JSON Input Format",
        "content": "TinySearch expects input data as a JSON array of objects, where each object represents a searchable document. The structure is flexible - you can include any fields you need. Common fields include title, body or content, url, author, date, and category, but you can use custom field names that match your data structure. The tinysearch.toml configuration file determines which fields get indexed for searching versus stored for display. Arrays of strings are automatically concatenated for indexing. Nested objects are flattened, and null values are handled gracefully. The JSON format supports standard data types and UTF-8 encoding for international content.",
        "section": "Input Format",
        "keywords": "json input format structure fields documents array objects",
        "doc_url": "https://docs.example.com/json-format",
        "version": "v0.9.0",
        "last_updated": "2024-02-25",
        "contributor": "Alex Rodriguez",
        "difficulty": "Beginner",
        "type": "Reference"
    },
    {
        "title": "CLI Commands and Options",
        "content": "The TinySearch command-line interface provides several modes for different use cases. Storage mode generates the search index from your JSON input. Search mode allows testing queries against a generated index. WASM mode creates WebAssembly files for browser deployment, including JavaScript glue code and an optional demo HTML file. Additional options include --release for production builds without demo files, --optimize for size optimization using wasm-opt, and --engine-version for specifying the TinySearch library version. Path options control output directories, and verbose logging helps debug configuration issues.",
        "section": "Command Line",
        "keywords": "cli commands options storage wasm search release optimize flags",
        "doc_url": "https://docs.example.com/cli-reference",
        "version": "v0.9.0",
        "last_updated": "2024-02-20",
        "contributor": "Maria Gonzalez",
        "difficulty": "Intermediate",
        "type": "Reference"
    },
    {
        "title": "WebAssembly Integration",
        "content": "TinySearch generates WebAssembly modules that can be integrated into any website. The WASM file contains the search index and search algorithms, while the JavaScript glue code provides a simple API for performing searches and handling results. Integration involves loading the WASM module, initializing the search engine, and calling search functions with query strings. Results are returned as JSON arrays with title, URL, and metadata for each match. The system supports asynchronous loading, error handling, and memory management. Performance is excellent with typical search times under 1ms for most queries.",
        "section": "Integration",
        "keywords": "webassembly wasm integration javascript api browser client-side",
        "doc_url": "https://docs.example.com/wasm-integration",
        "version": "v0.9.0",
        "last_updated": "2024-02-18",
        "contributor": "David Kim",
        "difficulty": "Advanced",
        "type": "Guide"
    },
    {
        "title": "Performance Optimization",
        "content": "TinySearch is designed for excellent performance, but several optimization techniques can improve search speed and reduce file size. Index size is primarily determined by content volume and vocabulary diversity. Using focused keywords and removing stopwords reduces index size. The --optimize flag enables wasm-opt compression, typically reducing file size by 20-30%. Content preprocessing like markdown stripping and normalization improves search relevance. For large datasets, consider splitting into multiple search indices or implementing progressive loading. Memory usage scales with index size, and the search algorithm is optimized for minimal allocations during query execution.",
        "section": "Performance",
        "keywords": "optimization performance speed file-size memory wasm-opt compression",
        "doc_url": "https://docs.example.com/performance",
        "version": "v0.9.0",
        "last_updated": "2024-02-15",
        "contributor": "Jennifer Liu",
        "difficulty": "Advanced",
        "type": "Guide"
    },
    {
        "title": "Static Site Generator Integration",
        "content": "TinySearch integrates seamlessly with popular static site generators including Jekyll, Hugo, Zola, Gatsby, and Next.js. The typical workflow involves generating a JSON index during the build process, running TinySearch to create WASM files, and including the search interface in your theme. Jekyll users can use liquid templates to generate the JSON index from post frontmatter and content. Hugo supports JSON output formats for automatic index generation. Modern frameworks like Gatsby and Next.js can generate indices programmatically during build time. Examples and starter templates are available for each platform, demonstrating best practices for integration and styling.",
        "section": "Integration",
        "keywords": "static-site-generators jekyll hugo gatsby nextjs zola build-process",
        "doc_url": "https://docs.example.com/ssg-integration",
        "version": "v0.9.0",
        "last_updated": "2024-02-12",
        "contributor": "Sophie Anderson",
        "difficulty": "Intermediate",
        "type": "Guide"
    },
    {
        "title": "Troubleshooting Guide",
        "content": "Common issues and solutions for TinySearch deployment and usage. MIME type errors when loading WASM files can be resolved by configuring your web server to serve .wasm files with the correct application/wasm content type. Large index files may cause memory issues in browsers - consider splitting content or using pagination. Search relevance can be improved by adjusting indexed fields and using more descriptive keywords. Build errors often relate to JSON formatting or configuration syntax. Network errors during WASM loading need proper CORS headers and HTTPS for production deployment. Debug mode provides detailed logging for diagnosing issues.",
        "section": "Troubleshooting",
        "keywords": "troubleshooting issues errors mime-type memory cors https debugging",
        "doc_url": "https://docs.example.com/troubleshooting",
        "version": "v0.9.0",
        "last_updated": "2024-02-10",
        "contributor": "Michael Torres",
        "difficulty": "Intermediate", 
        "type": "Guide"
    },
    {
        "title": "API Reference",
        "content": "Complete JavaScript API reference for TinySearch WebAssembly modules. The main entry point is init_tinysearch() which loads and initializes the WASM module asynchronously. The TinySearchWasm class provides search(query, numResults) method for executing queries. Results include title, url, and metadata fields as configured in your schema. Error handling covers WASM loading failures, invalid queries, and memory issues. Advanced methods include setStopwords() for custom word filtering and getStats() for index information. The API is promise-based and compatible with modern JavaScript environments including browsers and Node.js.",
        "section": "API Reference",
        "keywords": "api reference javascript methods functions init search results promises",
        "doc_url": "https://docs.example.com/api-reference", 
        "version": "v0.9.0",
        "last_updated": "2024-02-08",
        "contributor": "Emma Thompson",
        "difficulty": "Advanced",
        "type": "Reference"
    },
    {
        "title": "Examples and Templates",
        "content": "Ready-to-use examples and templates for common TinySearch use cases. The examples directory includes complete implementations for e-commerce product search, blog post search, and documentation search. Each example includes sample data, configuration files, and integration code. Templates are provided for popular frameworks and styling approaches. The e-commerce example demonstrates product catalogs with price and availability metadata. The blog example shows author and category filtering. Documentation examples include version and section organization. All examples include responsive design and accessibility considerations.",
        "section": "Examples", 
        "keywords": "examples templates ecommerce blog documentation samples starter-code",
        "doc_url": "https://docs.example.com/examples",
        "version": "v0.9.0",
        "last_updated": "2024-02-05",
        "contributor": "Carlos Mendez",
        "difficulty": "Beginner",
        "type": "Examples"
    },
    {
        "title": "Contributing Guidelines",
        "content": "Guidelines for contributing to TinySearch development including code style, testing requirements, and pull request process. The project welcomes contributions ranging from bug fixes to new features. Development setup requires Rust, wasm-pack, and Node.js for testing. Code follows standard Rust conventions with clippy linting and rustfmt formatting. All new features need comprehensive tests including unit tests and integration tests. Documentation updates are required for API changes. The review process includes automated testing, manual review, and performance benchmarking. Issues and feature requests are managed through GitHub with clear templates and labeling.",
        "section": "Contributing",
        "keywords": "contributing development code-style testing pull-requests github rust",
        "doc_url": "https://docs.example.com/contributing",
        "version": "v0.9.0",
        "last_updated": "2024-02-01",
        "contributor": "Ryan Park",
        "difficulty": "Advanced",
        "type": "Guide"
    }
]